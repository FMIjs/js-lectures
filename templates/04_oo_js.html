<section>
  <h1>ОО JavaScript</h1>
</section>

<section>
    <ul class="build">
        <li>Принципи в ООП</li>
        <li>Design patterns</li>
        <li>Наследяване</li>
        <li>Immediately-Invoked Function Expression (IIFE)</li>
        <li>Namespace pattern</li>
        <li>Module pattern</li>
        <li>AMD, CommonJS, ES.next</li>
        <li>Publish/subscribe</li>
        <li>Примерна архитектура</li>
    </ul>
</section>

<section>
    <h2>Принципи в ООП</h2>
    <h3>Сложност</h3>
    <ul class="build">
        <li>Големи проекти</li>
        <li>Голяма сложност</li>
        <li>Силен coupling</li>
    </ul>
</section>

<section class="fill">
    <h3>Малък проект</h3>
    <img src="../images/oo_js/dog-house.jpg" alt="" />
</section>

<section class="fill">
    <h3>Реален проект</h3>
    <img src="../images/oo_js/building-plan.jpg" alt="" />
</section>

<section>
    <h3>4 основни принципа</h3>
    <ul class="build">
        <li>Наследяване</li>
        <li>Полиморфизъм</li>
        <li>Абстракция</li>
        <li>Енкапсулация</li>
    </ul>
    <br /><br />
    <h4>Други принципи</h4>
    <ul class="build" style="font-style: italic;">
        <li>GRASP</li>
        <li>SOLID</li>
    </ul>
</section>

<section class="fill">
    <h3>Наследяване</h3>
    <img src="../images/oo_js/inheritance.jpg" alt="" />
    <ul class="build">
        <li>Преизползване на код</li>
    </ul>
</section>

<section>
    <h3>Полиморфизъм</h3>
    <ul class="build">
        <li>Различно поведение на даден метод в зависимост от това инстанция на кой клас от йерархията е обектът, който го извиква.</li>
    </ul>
    <div style="text-align: center;">
        <img src="../images/oo_js/polymorphism.gif" alt="" />
    </div>
</section>

<section>
    <h3>Абстракция</h3>
    <br />
    <img src="../images/oo_js/spacecraft.jpg" alt="" />
</section>

<section class="smaller">
    <h3>Енкапсулация</h3>
    <q>
        Абстракцията и енкапсулацията са допълващи се концепции: абстракцията се фокусира върху наблюдаемото поведение на обекта...енкапсулацията се фокусира върху имплементацията, която задейства това поведение...
    </q>
    <div class='author'>
        Grady Booch
    </div>
</section>

<section class="fill">
    <h3>Шаблони за дизайн</h3>
    <ul>
        <li>Чести проблеми</li>
        <li>Добри подходи</li>
        <li>Баланс</li>
    </ul>
</section>

<section>
    <h2>Наблюдател</h2>
    <h3>Проблем</h3>
    <ul class="build">
        <li>Управление на промените в състоянието</li>
        <li>Минимален каплинг</li>
        <li>Два подхода - push и pull</li>
    </ul>
</section>

<section>
<h3>Pull Наблюдател</h3>
<img src="../images/oo_js/observer.gif" alt="" style="margin: 30px; width:80%;" />
</section>

<section>
<h2>Прокси</h2>
<h3>Проблем</h3>
<ul class="build">
    <li>Remote proxy (cross-domain requests)</li>
    <li>Restriction proxy</li>
    <li>други...</li>
</ul>
</section>

<section>
<h3>Прокси</h3>
<img src="../images/oo_js/proxy.png" alt="" style="margin: 30px; width: 80%;" />
</section>

<section>
<h3>Адаптер</h3>
<h2>Проблем</h2>
<ul class="build">
    <li>Множество JavaScript библиотеки (jQuery, MooTools, Dojo, ExtJS...)</li>
    <li>Независимо от библиотеките приложение</li>
    <li>Динамична подмяна на библиотеката</li>
</ul>
</section>

<section>
<h3>Адаптер</h3>
<img src="../images/oo_js/adapter.png" alt="" style="margin: 30px; width: 80%;" />
</section>

<section>
    <h2>Наследяване</h2>
    <h3>Два подхода:</h3>
    <ul class="build">
       <li>(Псевдо) Класически</li>
       <li>Прототипен</li>
    </ul>
</section>

<section class="smaller">
    <h2>Класически</h2>
    <pre><code>
        function Person(name) {
          this._name = name;
        }
        Person.prototype.getName = function () {
          return this._name;
        };

        function Developer(name, languages) {
          Person.call(this, name);
          this.languages = languages;
        }
        Developer.prototype = new Person();

        var dev = new Developer('foo', ['JavaScript', 'Perl', 'Java']);
        console.log(dev.getName());     //"foo"
        console.log(dev._name);         //"foo"
        console.log(dev.languages[0]);  //"JavaScript"
    </code></pre>
</section>

<section>
  <pre><code>
  function Person(name) {
    this._name = name;
  }
  Person.prototype.getName = function () {
    return this._name;
  };

  function Developer(name, languages) {
    Person.call(this, name);
    this._languages = languages;
  }
  Developer.prototype = Object.create(Person.prototype);
  Developer.prototype.getLanguages = function (lang) {
    return thus._languages[lang];
  };

  var dev = new Developer('foo', ['JavaScript', 'Perl', 'C++', 'Simula']);
  console.log(dev.getName());
  console.log(dev._name);
  console.log(dev.getLanguages()[1]);
  </code></pre>
</section>

<section>
  <h2>Класическо наследяване в CoffeeScript</h2>
</section>

<section>
  <pre><code>
class Person
  constructor:  (@_name) ->
  getName: ->
    @_name;


class Developer extends Person
  constructor: (@name, @_languages) ->
  getLang: (idx) ->
    @_languages[idx];
  </code><pre>
</section>

<section>
    <pre><code>
var Developer, Person,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  };

Person = (function() {
  function Person(_name) {
    this._name = _name;
  }

  Person.prototype.getName = function() {
    return this._name;
  };

  return Person;

})();

Developer = (function(_super) {
  __extends(Developer, _super);

  function Developer(name, _languages) {
    this.name = name;
    this._languages = _languages;
  }

  Developer.prototype.getLang = function(idx) {
    return this._languages[idx];
  };

  return Developer;

})(Person);
    </code></pre>
</section>

<section>
    <h2>Класически (+/-)</h2>
    <ul>
        <li>Изглежда познат</li>
        <li class="fragment highlight-red">Липса на privacy</li>
        <li class="fragment highlight-red">Добавя ненужна сложност</li>
    </ul>
</section>

<section class="smaller">
    <h2>Функционално/Closure наследяване</h2>
    <pre><code>
        function Person(name) {
            var _name = name;
            this.getName = function () {
                return _name;
            };
        }
        function Developer(name, languages) {
            var _languages = languages;
            Person.call(name);
            this.getLanguages = function () {
                return _languages;
            };
        }
        Developer.prototype = new Person();
        var dev = new Developer('foo', ['JavaScript', 'Perl', 'Java']);
        console.log(dev._name);     //undefined
        console.log(dev.getName()); //"foo"
    </code></pre>
</section>

<section>
    <h2>Функционално (+/-)</h2>
    <ul class="build green">
        <li>Изглежда сравнително познато</li>
        <li>Имаме privacy</li>
        <li class="fragment highlight-red">Множество копия на методите, дефинирани в конструкторната функция</li>
        <li class="fragment highlight-red">Добавя ненужна сложност</li>
    </ul>
</section>

<section>
    <h2>Прототипно наследяване</h2>
    <pre><code>
        var person = {
            name: 'foo',
            age: 42
        };

        var dev = Object.create(person);
        dev.languages = ['JavaScript', 'Perl', 'Java'];

        console.log(dev.name);         //"foo"
        console.log(dev.languages[0]); //"JavaScript"
    </code></pre>
</section>

<section>
    <h2>Прототипно наследяване (+/-)</h2>
    <ul class="build green">
        <li>Простота</li>
        <li class="fragment highlight-red">Изглежда необичайно</li>
        <li class="fragment highlight-red">Нямаме privacy (*)</li>
    </ul>
</section>


<section>
  <h2>Useful ES5 methods (1)</h2>
  <ul class="build">
    <li><strong>Object.create</strong> - създава обект с прототип своя първи аргумент</li>
    <li><strong>Object.getPrototypeOf</strong> - връща прототипа на първия си аргумент</li>
    <li><strong>Object.keys</strong> - връща масив всички enumerable ключове на даден обект</li>
    <li><strong>Object.getOwnPropertyNames</strong> - връща масив с всички ключове на даден обект</li>
    <li><strong>Object.defineProperty(obj, prop, descriptor)</strong> - дефинира поле</li>
  </ul>
</section>

<section>
  <h3>Object.defineProperty пример</h3>
  <pre><code>
    Object.defineProperty(obj, "key", {
      enumerable: false,
      configurable: false,
      writable: false,
      value: 'static'
    });
  </code></pre>
</section>

<section>
  <h3>Object.defineProperty</h3>
  <ul>
    <li><strong>configurable</strong> - true ако искаме даденото поле да може да бъде изтривано, а дескриптора му променян.</li>
    <li><strong>enumerable</strong> - указва дали това поле ще се покаже при "enumeration"</li>
    <li><strong>value</strong> - The value associated with the property. Can be any valid JavaScript value (number, object, function, etc) Defaults to undefined.</li>
    <li><strong>writable</strong> - True if and only if the value associated with the property may be changed with an assignment operator. Defaults to false.</li>
  </ul>
</section>

<section>
  <h2>Useful ES5 methods (2)</h2>
  <ul class="build">
    <li><strong>Object.seal</strong> - забранява изтриване и добавяне на нови полета</li>
    <li><strong>Object.freeze</strong> - ефектът на seal + забрана за промяната на свойствата</li>
    <li><strong>Object.preventExtensions</strong></li>
    <li><strong>Object.isSealed</strong></li>
    <li><strong>Object.isFrozen</strong></li>
    <li><strong>Object.isExtensible</strong></li>
    <li><strong>Object.getOwnPropertyDescriptor</strong></li>
  </ul>
</section>

<section>
  <h2>Mixins</h2>
  <p>Колекционираме функционалност чрез разширението на даден обект. За първи път се срещат в езика Flavors.</p>
</section>

<section>
    <pre><code>
function mixin(receivingClass, givingClass) {
  if (arguments[2]) {
    for (var i = 2, len = arguments.length; i < len; i++) {
      receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]];
    }
  } else {
    for (var methodName in givingClass.prototype) {
      if (!Object.hasOwnProperty(receivingClass.prototype, methodName)) {
        receivingClass.prototype[methodName] = givingClass.prototype[methodName];
      }
    }
  }
}
    </code></pre>
</section>

<section>
    <pre><code>
  mixin(dest, source, 'prop1', 'prop2');
    </code></pre>
</section>

<section class="smaller">
    <h2>Полиморфизъм</h2>
    <pre><code>
function Person(name) {
  this._name = name;
}
Person.prototype.speak = function () {
  return 'My name is ' + this._name + '.';
};
function Developer(name, languages) {
  Person.call(this, name);
  this.languages = languages || [];
}
Developer.prototype = new Person();
Developer.prototype.speak = function () {
  return 'My name is ' + this._name + ' and I know ' + (this.languages[0] || 'nothing') + '.';
};

var person = new Person('foo');
console.log(person.speak()); //"My name is foo and."
person = new Developer('foo', ['JavaScript', 'Perl', 'Java']);
console.log(person.speak()); //"My name is foo and I know JavaScript."
    </code></pre>
</section>

<section>
    <h2>Immediately-Invoked Function Expression (IIFE)</h2>
    <h3>Проблем</h3>
    <ul class="build">
        <li>Инициализация</li>
        <li>Запазване на глобалното пространство "чисто"</li>
        <li>Извършване на инициализацията веднъж</li>
    </ul>
</section>

<section>
    <h3>Примерно решение (1)</h3>
    <pre><code>
function addHandlers() {
  //body
}
function performLayout() {
  //body
}
addHandlers();
performLayout();
    </code></pre>
    <ul class="build">
        <li class="fragment highlight-red">Няколко глобални функции</li>
        <li class="fragment highlight-red">Могат да бъдат извикани няколко пъти</li>
    </ul>
</section>

<section>
    <h3>Примерно решениe (2)</h3>
    <pre><code>
function init() {
  function addHandlers() {
  }
  addHandlers();
}
init();
    </code></pre>
    <ul class="build">
      <li class="fragment highlight-red">"Замърсяване" на глобалният namespace (init е глобална)</li>
      <li class="fragment highlight-red">init може да бъде извикан множество пъти</li>
    </ul>
</section>

<section>
    <h3>Примерно решение (3)</h3>
    <pre><code>
var init = function () {
  function addHandlers() {
  }
   addHandlers();
};
init();
delete window.init;
    </code></pre>
    <ul class="build">
        <li class="fragment highlight-red">Не особено елегантно</li>
    </ul>
</section>

<section>
    <h3>Решение</h3>
    <pre><code>
       (function (w, d) {
         //initialization
       }(window, document));
    </code></pre>
    <ul class="build">
        <li class="fragment highlight-green">Решава всички проблеми</li>
        <li class="fragment highlight-red">Трудно за разбиране</li>
    </ul>
</section>

<section>
    <h3>Пример</h3>
    <pre><code>
//Асинхронно зареждане на SDK на facebook
(function(d){
    var js, id = 'facebook-jssdk',
        refr = d.getElementsByTagName('script')[0];
    if (d.getElementById(id)) {return;}
    js = d.createElement('script'); js.id = id; js.async = true;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
    refr.parentNode.insertBefore(js, refr);
}(document));
    </code></pre>
</section>

<section>
    <h2>Namespace шаблонът</h2>
    <h3>Проблем</h3>
    <ul class="build">
        <li>Организация на кода</li>
        <li>Групиране на логически свързани идентификатори</li>
        <li>Справяне с колизии</li>
        <li>Java - пакети</li>
        <li>C++, C# - namespaces</li>
        <li>JavaScript - ?!</li>
    </ul>
</section>

<section>
    <h3>Обектите в JavaScript</h3><br />
    <div>Притежават:</div><br>
    <ul class="build">
        <li>Свойства (properties) - обекти</li>
        <li>Методи - обекти</li>
    </ul>
</section>

<section>
    <h3>Обектният литерал</h3>
    <pre><code>
    var person = {
      talk: 'Foo',
      action: function () {
        console.log('I\'m ' + this.name);
      }
    };
    </code></pre>
    <ul class="build green">
        <li>По-малко код</li>
        <li>Почти два пъти по-бързо в сравнение с new</li>
        <li class="fragment highlight-red">По-трудно за разбиране?</li>
    </ul>
</section>

<section>
    <h3>Влагане на обекти</h3>
    <pre><code>
var foo = {
  bar: {
    foobar: { prop: 'I\'m inside foobar!' }
  }
};
    </code></pre>
</section>

<section>
    <h3>Namespace функция</h3>
    <pre><code>
    function namespace(namespaceString) {
      var parts = namespaceString.split('.'),
          parent = window,
          currentPart = '';

      for(var i = 0, length = parts.length; i &lt; length; i++) {
        currentPart = parts[i];
        parent[currentPart] = parent[currentPart] || {};
        parent = parent[currentPart];
      }

      return parent;
    }
    </code></pre>
</section>

<section>
    <h3>Примерно използване</h3>
    <pre><code>
        (function () {
          var stream = namespace('com.appblast.stream');

          stream.xhr = function () {
            //implementation
          };

          stream.websocket = function () {
            //implementation
          };
        }());
    </code></pre>
</section>

<section>
    <h2>Module pattern</h2>
    <h3>Проблем</h3>
    <ul class="build">
        <li>Data hiding</li>
        <li>Енкапсулация</li>
        <li>Абстракция</li>
        <li>Сложност</li>
    </ul>
</section>

<section>
    <h3>Създаване на "класове"</h3>
    <pre><code>
        function Person(name) {
          this.name = name;
          this.talk = function () {
            return this.name + " is talking!";
          };
        }
        var person = new Person('Foo');
        console.log(person.name); // "Foo"
        console.log(person.talk()); // "Foo is talking!"
    </code></pre>
    <ul class="build green">
        <li>Основна енкапсулация</li>
        <li>Абстракция</li>
        <li class="fragment highlight-red">Нямаме data hiding</li>
    </ul>
</section>

<section>
    <h3>Scope</h3>
    <pre><code>
        function foo() {
          console.log('It\'s me - foo.');
          var bar = function () {
            console.log('It\'s me - bar');
          };
          bar();
        }
        function foobar() {
          console.log('It\'s me - foobar.');
        }
        foo();  //Hey it's me - foo
                //Hey it's me - bar

        bar();    //ReferenceError: bar is not defined
        foobar(); //It's me - foobar
    </code></pre>
</section>

<section>
    <h3>Module pattern</h3>
    <pre><code>
    var module = (function () {
      function privateFoo() {
        console.log('The private foo.');
      }
      return {
        publicFoo: function () {
          privateFoo();
          console.log('The public foo.');
        }
      };
    }());
    module.publicFoo();  //'The private foo.'
                         //'The public foo.'
    module.privateFoo(); //TypeError: Object #&lt;Object&gt;
                         // has no method 'privateFoo'
    </code></pre>
</section>

<section>
    <h3>Пример</h3>
    <pre><code>
    var website = (function () {
      var title = 'Default title';
      return {
        setTitle: function (t) {
          title = t;
          document.title = title;
        },
        getTitle: function () {
          return title;
        }
      };
    }());
    website.setTitle('Sample title');
    console.log(website.getTitle()); //'Sample title'
    </code></pre>
</section>

<section>
    <h3>Module pattern - вариант (1)</h3>
    <pre><code>
    var module = (function () {
      function private() {
        console.log('Private method');
      }
      function public() {
        console.log('Public method');
      }
      return {
        public: public
      };
    }());
    </code></pre>
</section>

<section class="smaller">
    <pre><code>
    var module = (function () {
      function public() {
        private();
      }
      function anotherPublic() {
        console.log('anotherPublic');
      }
      function private() {
        anotherPublic();
      }
      return {
        public: public,
        anotherPublic: anotherPublic
      };
    }());

    module.public(); // 'anotherPublic'
    module.anotherPublic = function () {
        console.log('Brand new public');
    };
    module.public(); // 'anotherPublic'
    </code></pre>
</section>

<section>
    <h2>AMD и CommonJS</h2>
</section>

<section>
    <h3>CommonJS</h3>
    <p>Преизползваеми парчета JavaScript, които предоставят специфични обекти на зависим от тях код.</p>
    <div>Глобални:</div>
    <ul>
        <li>exports</li>
        <li>require</li>
    </ul>
</section>

<section>
    <h3>CommonJS exports</h3>
    <p>С променливата <strong>exports</strong> указваме, какво искаме да предоставим на останалите модули.</p>
    <pre><code>
var lib = require('./utils/lib'), //relative
    fooLib = require('fooLib');

lib.doAwesomeThing();
fooLib();

function bar() {
  //body
}

exports.bar = bar;
    </code></pre>
</section>

<section>
    <h3>CommonJS exports</h3>
    <pre><code>
//Human.js
function Human(name) {
  this.name = name;
}
exports.Human = Human;

//app.js
var Human = require('./Human.js').Human;

var p = new Human('foo');
console.log(p.name); //'foo'
    </code></pre>
</section>

<section>
    <h3>CommonJS</h3>
    <p>Типично използване на CommonJS е в Node.js. За да използваме функционалност предоставена от даден модул не е нужно да използваме callbacks или promises, тъй като зареждането на модула се случва синхронно.</p>
</section>

<section>
    <h3><b>A</b>synchronous <b>M</b>odule <b>D</b>efinition</h3>
    <ul>
        <li>Модулен JavaScript за Web (browser first подход)</li>
        <li>Dojo - XHR + eval</li>
        <li>Позволява асинхронно зареждане на зависимостите</li>
        <li>Без coupling между модула и кода за зареждането му</li>
        <li><a href="https://groups.google.com/forum/#!forum/amd-implement">Mailing list</a></li>
    </ul>
</section>

<section>
    <h3>Дефиниция на модул</h3>
    <pre><code>
define(
    module_id /* optional */,
    [dependencies] /* optional */,
    definition function /* function for instantiating the module or object */
);
    </code></pre>
</section>

<section>
    <h3>Специални зависимости</h3>
    <ul>
        <li>require</li>
        <li>exports</li>
        <li>module</li>
    </ul>
    <p class="fragment">Това са и аргументите по подразбиране, които factory функцията приема</p>
</section>

<section>
    <h3>Зависимостите</h3>
    <ul>
        <li>Могат да се задават с релативни идентификатори</li>
        <li>Зареждането им се стартира в реда им</li>
        <li>Зависимостите се подават на фабриката в реда, в който са зададени в масива</li>
    </ul>
</section>

<section>
    <h3>Пример</h3>
    <pre><code>
 define(["alpha"], function (alpha) {
     return {
       verb: function(){
         return alpha.verb() + 2;
       }
     };
 });
    </code></pre>
</section>

<section>
    <h3>Пример</h3>
    <pre><code>
 define("alpha", ["require", "exports", "../beta"], function (require, exports, beta) {
     exports.verb = function() {
         return beta.verb();
     }
 });
    </code></pre>
</section>

<section>
    <h3>Пример</h3>
<pre><code>
 define({
   add: function(x, y){
     return x + y;
   }
 });
 </code></pre>
</section>

<section>
    <h3>Пример (CommonJS в AMD)</h3>
    <pre><code>
 define(function (require, exports, module) {
   var a = require('a'),
       b = require('b');

   exports.action = function () {};
 });
    </code></pre>
</section>

<section>
  <pre><code>
require(["namespace/dependencyC"], function (depC) {
  //our "main"
});
  </code></pre>
</section>

<section>
  <h3>Имплементации</h3>
  <ul>
    <li>require.js - AMD</li>
    <li>curl.js - AMD, CommonJS</li>
  </ul>
</section>

<section>
    <h3>ES.next</h3>
    <p class="fragment">ES.next, ES6, ES Harmony...добавя вградена модулна поддръжка в езика (освен вече известните класове).</p>
    <p><a href="https://github.com/google/traceur-compiler" target="_blank">Ако искате да използвате ES.next today!</a></p>
</section>

<section>
    <h3>ES.next дефиниране на модул</h3>
<pre><code>
module 'math' {
    export function sum(x, y) {
        return x + y;
    }
    export var pi = 3.141593;
}
 </code></pre>
</section>

<section>
    <h3>ES.next зареждане на модул</h3>
    <p>ES.next модулите се зареждат и компилират по време на компилацията на зависимите от тях модули.</p>
<pre><code>
import {sum as sm, pi} from 'math';

alert("2π = " + sm(pi, pi));
 </code></pre>
или
<pre><code>
module Math from 'math';

alert("2π = " + Math.sum(Math.pi, Math.pi));
 </code></pre>
</section>

<section>
    <h3>ES.next зареждане на отдалечен модул</h3>
<pre><code>
module $ from 'http://code.jquery.com/jquery.x.x.x.js';

alert($.parseJSON('{ "hi": "world" }'));
 </code></pre>
</section>

<section>
    <h2>Publish/subscribe</h2>
    <h3>Проблем</h3>
    <ul class="build">
        <li>Загуба на coupling</li>
        <li>Лесно преизползване на код</li>
        <li>Лесна поддръжка</li>
    </ul>
</section>

<section>
    <h3>Възможно решение</h3>
    <pre><code>
    //Модул 1
    notify: function () {
      var event = document.createEvent('Events');
      event.initEvent('custom-event', true, true);
      event.customData = { foo: 'bar' };
    }
    //
    //Модул 2
    window.addEventListener('custom-event', function (e) {
      console.log(e.foo);
    });
    //end module1
    module1.notify(); //'bar'
    </code></pre>
    <ul class="build red">
        <li class="fragment highlight-red">window се използва като медиатор</li>
        <li class="fragment highlight-red">Възможни колизии</li>
    </ul>
</section>

<section class="smaller">
    <h3>Решение</h3>
    <pre><code>
        var pubsub = {};
        (function(q) {
            var topics = {},
                subUid = -1;
            q.publish = function (topic, args) {
              if (!topics[topic]) {
                return false;
              }
              var subscribers = topics[topic],
                  len = subscribers ? subscribers.length : 0;
              while (len--) {
                subscribers[len].func(topic, args);
              }
              return this;
            };
            q.subscribe = function (topic, func) {
              if (!topics[topic]) {
                topics[topic] = [];
              }
              var token = (++subUid).toString();
              topics[topic].push({
                token: token,
                func: func
              });
              return token;
            };
        }(pubsub));
    </code></pre>
</section>

<section>
    <h2>Примерна архитектура</h2>
    <h3>Проблем</h3>
    <ul class="build">
        <li>Справяне със сложността</li>
        <li>Лесна подмяна на компоненти</li>
        <li>Преизползваемост на компонентите</li>
    </ul>
</section>

<section>
    <h3>Ядро</h3>
    <h4>Адаптер</h4>
    <ul class="build">
        <li>Стандартизиран интерфейс за DOM, Ajax или друга библиотека.</li>
        <li>Предоставяне на този интерфейс на Sandbox</li>
    </ul>
</section>

<section>
    <pre><code>
        App.core.dom = {
          setWidth: function (elem, width) {
            $(elem).width(width);
          },
          getWidth: function (elem) {
            return $(elem).width();
          },
          getOffset: function (elem) {
            return $(elem).offset();
          }
        };
        App.core.ajax = {
          get: function (url, data) {
            $.ajax({
              type: 'get',
              url: url,
              data: data
            });
          }
        };
    </code></pre>
</section>

<section>
    <h3>The Sandbox</h3>
    <h4>Pub-sub/Proxy</h4>
    <ul class="build">
        <li>Предоставя основен API на модулите</li>
        <li>Модулите комуникират помежду си посредством Sandbox</li>
        <li>Осигурява ограничение (в случай, че е необходимо)</li>
    </ul>
</section>

<section class="smaller">
    <pre><code>
        App.sandbox = (function (core) {
          var modules = {},
              topics = {},    //publish/subscribe
              //...
              moduleInterface = {
                dom: core.dom,
                ajax: core.ajax,
                publish: publish,
                subscribe: subscribe
              };
          function start(moduleId) {
            var module = modules[moduleId];
            if (module !== undefined &amp;&amp; typeof module.init === 'function') {
              modules.init.call(null, moduleInterface);
            }
          }
          return {
            register: register, //register module
            start: start,
            stop: stop
          };
        }(App.core));
    </code></pre>
</section>

<section>
    <h3>Модулите</h3>
    <h4>Module шаблонът</h4>
    <ul class="build">
        <li>Блоковете, с които изграждаме приложението</li>
        <li>Не използват глобални променливи!</li>
        <li>Не комуникират директно с други модули, използват sandbox.</li>
    </ul>
</section>

<section>
    <pre><code>
    App.sandbox.register('news', (function () {
      function init(sandbox) {
        addHandlers();
        //...
      }
      function addHandlers() {
        //...
      }
      return {
        init: init
      };
    }());
    </code></pre>
</section>

<section class="current">
    <img src="../images/oo_js/architecture.png" alt="" />
</section>

<section>
    <iframe width="640" height="360" src="http://www.youtube.com/embed/vXjVFPosQHw?theme=light" frameborder="0"></iframe>
</section>

<section>
    <h2>Примерна архитектура (+/-)</h2>
    <ul class="build green">
        <li>Лесна за изграждане</li>
        <li>Енкапсулация</li>
        <li>Слаб coupling между модулите</li>
        <li>Преизползваемост</li>
        <li class="fragment highlight-red">Трудна за unit тестване</li>
        <li class="fragment highlight-red">Ограничена функционалност (в сравнение с AngularJS, Ember.js и др)</li>
    </ul>
</section>
